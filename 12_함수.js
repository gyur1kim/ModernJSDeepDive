/*
함수 : 입력과 출력이 있당.
하나의 실행 단위(코드 블록)
함수는 같은 코드를 여러 번 사용할 수 있음(코드의 재사용) => 유지보수의 편의성 높임, 코드의 신뢰성 높임

매개 변수 : 0개 이상의 매개변수, 인수가 순서대로 할당, 함수 내의 변수이므로 식별자 네이밍 규칙 준수
인수 : 함수에 넣는 입력값
반환값
함수 이름 : 식별자이므로 식별자 네이밍 규칙 준수, 기명함수/익명함수
 */

//함수를 정의하는 방법
/*
- 함수 선언문 : 자바스크립트 엔진에서 암묵적으로 함수 이름과 동일 이름의 식별자 생성, 그 식별자에 함수 객체를 할당
- 함수 표현식 : 평가되는 식이다. 식별자에 직접 할당한다. 보통 익명함수를 사용하고, 기명함수를 사용해도 함수를 호출하려면 함수 이름이 아니라 식별자를 이용.
- 함수 생성자 함수
- 화살표 함수
 */

//함수 선언문
/*
함수 선언문은 함수 이름을 생략할 수 없다(익명 함수 X)

함수 선언문은 표현식(평가되는 것 X)이 아니라 문이다.
따라서 크롬에서 실행하면 문을 실행한 결과인 undefined가 출력된다. => 문은 변수에 할당할 수 없는데?(if문을 떠올려보자)

함수 선언문은 자바스크립트 엔진에서 암묵적으로 식별자를 생성함
함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성, 거기에 함수 객체를 할당한다.
 */
function a(x, y){
    return x+y;
}
console.log(a(2+5));

//함수 표현식, 변수에 함수 리터럴을 할당하는 것 => 이 함수는 평가되어 값을 생성(함수 = 객체)
/*
함수 표현식은 마치 함수 선언문을 변수에 할당하는 것 같다. 선언문은 변수에 할당할 수 없는데..?
자바스크립트 엔진이 눈치껏 함
혼자 사용되면(값으로 평가되지 않는 경우) 함수 선언'문'으로 해석한다
어딘가에 할당된다거나 피연산자로 사용되면(값으로 평가되는 경우) 함수 표현'식'으로 해석한다.

함수는 함수 이름으로 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출한다.
아래의 예시는 f식별자가 함수를 가리키므로, f를 써야 호출된다.
일반적으로 함수 표현식은 익명 함수를 사용한다.
 */
var f = function b(x, y){
    return x+y;
}
console.log(b(2+5));        //b는 정의되지 않았다고 나온다. 왜냐면 함수 표현식을 f라는 변수에 저장한 것이기 때문이다.
console.log(f(2+5));