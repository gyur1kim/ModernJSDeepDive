//스코프란
/*
스코프는 유효범위임, 즉 매개변수의 유효범위가 어디까지인지?

var 키워드로 선언한 변수와 let, const로 선언한 변수의 스코프는 다르게 동작한다.
변수는 자신이 선언된 위치에 의해 자신이 유효한 범위가 결정된다.

=> 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
   식별자가 유효한 범위를 스코프라고 한다.
 */
var x = 'global';
function foo(){
    var x = 'local';
    console.log(x);     //local 출력
}
foo();
console.log(x);         //global 출력

//식별자 결정
/*
위의 예제에서, x 변수가 2개 존재한다. 이 때, 자바스크립트 엔진은 어떤 변수를 참조해야 할 것인지 결정해야 한다.
결정할 때는 스코프를 통해 결정한다. 따라서 스코프는 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.

엔진은 코드의 문맥을 고려한다.
렉시컬 환경 : 코드가 어디서 실행되며 주변에 어떤 코드가 있는지 -> 코드의 문맥은 렉시컬 환경으로 이루어진다.
실행 컨텍스트 : 이를 구현한 것(?) -> 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.

위의 예제에서 변수 x 2개는 이름은 같지만, 스코프가 다른 별개의 변수다.
global 값이 들은 x 변수는 어디서든 참조가 가능하지만, foo 함수 내부의 x값은 함수 외부에서 참조할 수 없다

만약 스코프라는 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키므로 프로그램 전체에서 하나만 사용 가능하다.
하지만!! 식별자는 고유한 이름을 말한다 즉, 식별자는 어떤 값을 구별할 수 있어야 하므로 유일해야 한다.
스코프 내에서 식별자는 유일해야 하고, 스코프가 다르다면 같은 이름의 식별자를 사용할 수 있다(=네임스페이스)
스코프 내에서 중복 선언은 허용되지만, 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생한다. 비추천!
 */

//스코프 종류
/*
전역(global), 지역(local)으로 구분한다. <- 변수가 선언된 위치에 따라 구분된다.

전역 : 코드의 가장 바깥 부분, 전역은 전역 스코프를 만들고, 전역 스코프에 선언된 변수는 전역 변수이다. 어디서든 참조 가능
지역 : 함수 몸체 내부, 지역 스코프를 만든다, 지역 스코프에 선언된 변수는 지역 변수이다. 지역 변수는 자신의 지역 스코프와 그 하위 스코프에서 유효.
 */